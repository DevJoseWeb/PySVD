# Daniel Alabi and Cody Wang

import math
import random

class SvdMatrix:
    def __init__(self, trainfile, nusers, nmovies, r):
        self.M = [[None]*nmovies]*nusers
        self.Up = [[None]*r]*nusers
        self.Vp = [[None]*r]*nmovies
        self.r = r
        self.lrate = 0.001
        self.regularizer = 0.02
        self.nusers = nusers
        self.nmovies = nmovies

        # fill in utility matrix
        # None for absent
        # rating for present
        f = open(trainfile)
        
        for line in f:
            newline = [int(each) for each in line.split("\t")]
            userid, movieid, rating = newline[0], newline[1], newline[2]
            self.M[userid-1][movieid-1] = rating

    # returns the value of this matrix at the specified row
    # and column
    def value(self, row, column):
        rVec = self.Up[row]
        cVec = self.Vp[column]
        return sum([rVec[i]*cVec[i] for i in range(len(rVec))])

    def magnitudeCol(self, arr, col):
        return sum([arr[i][col]**2 for i in range(len(arr))])

    # returns the array of singular values for this
    # decomposition
    def singularValues(self):
        return [self.singularValue(i) for i in range(self.r)]
    
    # d -> dimension of singular value
    def singularValue(self, d):
        return self.magnitudeCol(self.Up, d) * \
            self.magnitudeCol(self.Vp, d)
            
    def predict(self, i, j, rVector, cVector, cacheEntry):
        return cacheEntry + rVector[i] * cVector[j]

    def relDiff(self, x, y):
        return abs(x-y)/(abs(x)+abs(y))

    def train(self, eps, rmseimprov, maxepoch=1000):
        nusers = self.nusers
        nmovies = self.nmovies
        # number of entries in matrix
        nEntries = self.nusers * nmovies

        cache = [[0.0]*nmovies]*nusers

        rVectors = [None]*self.r
        cVectors = [None]*self.r

        for k in range(self.r):
            rVector = [1/math.sqrt(self.r)]*nusers
            cVector = [1/math.sqrt(self.r)]*nmovies

            rmselast = float("inf") # stores last rmse
            for epoch in range(maxepoch):
                sse = 0.0
                for i in range(nusers):
                    for j in range(nmovies):
                        # ignore empty entries
                        if self.M[i][j] == None: continue                        

                        prediction = self.predict(i, j, rVector, cVector, cache[i][j])
                        error = self.M[i][j] - prediction
                        sse += error * error
                        
                        # get current row, column
                        cRow = rVector[i]
                        cColumn = cVector[j]

                        rVector[i] += self.lrate * (error * cColumn - self.regularizer * cRow)
                        cVector[j] += self.lrate * (error * cRow - self.regularizer * cColumn)

                rmse = math.sqrt(sse/nEntries)
                print "epoch=", epoch, "; rmse=", rmse, "; relDiff=", self.relDiff(rmse, rmselast)
                if self.relDiff(rmse, rmselast) < eps or rmse < rmseimprov:
                    print "Converged in epoch=", epoch, "; rmse=", rmse, \
                        "; relative difference=", self.relDiff(rmse, rmselast)
                    break
                rmselast = rmse
            print "order k=", k, "; rmse=", rmselast
            rVectors[k] = rVector
            cVectors[k] = cVector

            for i in range(nusers):
                for j in range(nmovies):
                    cache[i][j] = self.predict(i, j, rVector, cVector, cache[i][j])
                    print "cache[i][j]=", cache[i][j]

                                    
                                               
if __name__ == "__main__":
    f = open("ua.base")

    svd = SvdMatrix("ua.base", 943, 1682, 20)
    svd.train(.001, 0.01)




